title: Жизненный цикл
---

## Жизненный цикл брокера
Этот раздел описывает, что происходит, когда брокер запускается и останавливается.

### Логика запуска
При запуске брокер пытается установить связь с транспортом. Когда это сделано, он не публикует список локальных сервисов удаленным узлам, потому что он еще не может принять запрос. Она запускает все сервисы (вызовы каждый [service `started` handler](lifecycle.html#started-event-handler)). После успешного запуска всех сервисов брокер публикует список локальных сервисов удаленным узлам. Поэтому удаленные узлы отправляют запросы только после того, как все локальные службы будут правильно инициализированы и запущены.

<div align="center">
    <img src="assets/lifecycle/broker-start.svg" alt="Диаграмма жизненного цикла запуска брокера" />
</div>

{% note warn Avoid deadlocks %}
Взаимоблокировки могут возникнуть, когда две службы ждут друг друга. Например: сервис `users` зависит от `dependencies: ["posts"]` и сервис `posts` имеет зависимость `dependencies: ["users"]`. Чтобы избежать этого, удалите соответствующую службу из зависимостей `dependencies` и используйте вместо этого метод `this.waitForServices` в обработчике `started`.
{% endnote %}

### Логика остановки
Когда вы вызываете `broker.stop` или останавливаете процесс, во первых брокер публикует пустой список сервисов на удаленные узлы, так что они будут направлять запросы в другие экземпляры сервиса вместо останавливаемого. Далее брокер начинает [остановку](#stopped-event-handler) всех локальных сервисов. После этого транспорт отключается и завершается процесс.

<div align="center">
    <img src="assets/lifecycle/broker-stop.svg" alt="Диаграмма жизненного цикла останова брокера" />
</div>

## Жизненный цикл сервиса
Этот раздел описывает, что происходит, когда сервис запускается и останавливается, и как вам следует использовать обработчики событий жизненного цикла.

### Обработчик `created`
Этот обработчик запускается, когда создается экземпляр сервиса (например: во время `broker.createService` или `broker.loadService`). Вы можете использовать его для создания экземпляров других модулей (например, http сервера, модулей БД) и хранения их в `this`.

```js
const http = require("http");

module.exports = {
    name: "www",
    created() {
        // Create HTTP server
        this.server = http.createServer(this.httpHandler);
    }
};
```

{% note info %}
Это синхронный обработчик событий. **Нельзя** возвращать `Promise` и **нельзя** использовать `async/await`.
{% endnote %}

### Обработчик `started`
Этот обработчик запускается, когда вызывается `broker.start` и брокер запустил все локальные сервисы. Используйте его для подключения к базе данных, открытия сокетов... и т.д.

```js
module.exports = {
    name: "users",
    async started() {
        try {
            await this.db.connect();
        } catch(e) {
            throw new MoleculerServerError("Unable to connect to database.", e.message);
        }
    }
};
```

{% note info %}
Это асинхронный обработчик событий. Можно вернуть `Promise` или использовать `async/await`.
{% endnote %}

### Обработчик `stopped`
Этот обработчик запускается, когда вызывается `broker.stop` и брокер начинает останавливать все локальные сервисы. Используйте его для закрытия соединений с базой данных, закрытия сокетов...и т.д.

```js
module.exports = {
    name: "users",
    async stopped() {
        try {
            await this.db.disconnect();
        } catch(e) {
            this.logger.warn("Unable to stop database connection gracefully.", e);
        }
    }
};
```

{% note info %}
Это асинхронный обработчик событий. Можно вернуть `Promise` или использовать `async/await`.
{% endnote %}
